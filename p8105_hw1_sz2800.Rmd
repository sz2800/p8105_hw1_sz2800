---
title: "p8105_hw1_sz2800.Rmd"
author: "Stephanie Zhen"
date: "9/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading library tidyverse
```{r}
library(tidyverse)
```
##Q1: Create a data frame comprised of:

#A random sample of size 8 from a standard Normal distribution.

#A logical vector indicating whether elements of the sample are greater than 0.

#A character vector of length 8.

#A factor vector of length 8, with 3 different factor “levels.”

```{r}
hw1q1_df = tibble(
  ran_sample = rnorm(8),
  vec_logical = ran_sample > 0,
  vec_char = c("breakfast", "lunch", "dinner",  "sleep", "coffee", "stars", "nap", "snacks"),
  vec_factor = factor(c("morning", "afternoon", "night", "night", "morning", "night", "afternoon", "afternoon"))
)
```

##Taking mean of ran_sample, vec_logical, vec_char, vec_factor
```{r}
mean(pull(hw1q1_df, ran_sample))
mean(pull(hw1q1_df, vec_logical))
mean(pull(hw1q1_df, vec_char))
mean(pull(hw1q1_df, vec_factor))
```
##The mean is -0.2180989 for ran_sample.

##The mean for vec_logical is 1.

##For vec_char, and vec_factors, it returns NA. This makes sense because vec_char and vec_factors are not logicals nor numerics.


##Applying "as.numeric" function to the vec_logical, vec_char, and vec_factor.

```{r}
mean(as.numeric(pull(hw1q1_df, vec_logical)))
mean(as.numeric(pull(hw1q1_df, vec_char)))
mean(as.numeric(pull(hw1q1_df, vec_factor)))
```
##After applying as.numeric (), the mean for vec_logical is 1. TRUE is coded as 1, and FALSE is coded as 0.

##After applying as.numeric () for vec_char, an error message was returned: "NA was introduced by coercion". The character variables can not be cohered into numeric values

##After applying as.numeric (), the mean for vec_factor is 2. The levels get assigned a numeric value arbitarally?

##Convert the logical vector to numeric, and multiply the random sample by the result.
```{r}
as.numeric(pull(hw1q1_df, vec_logical)) * pull(hw1q1_df,ran_sample)
```

##Convert the logical vector to a factor, and multiply the random sample by the result
```{r}
as.factor(pull(hw1q1_df, vec_logical)) * pull(hw1q1_df,ran_sample)
```
##Returns "NA"

##Convert the logical vector to a factor and then convert the result to numeric, and multiply the random sample by the result.
```{r}
as.numeric(as.factor(pull(hw1q1_df, vec_logical))) * pull(hw1q1_df,ran_sample)
```


##Create a data frame comprised of:

#x: a random sample of size 500 from a standard Normal distribution

#y: a random sample of size 500 from a standard Normal distribution

#A logical vector indicating whether x + y > 1

#A numeric vector created by coercing the above logical vector

#A factor vector created by coercing the above logical vector
```{r}
hw1q2_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  q2_logical = x + y > 1,
  q2_numeric = as.numeric(q2_logical),
  q2_factor = as.factor(q2_logical)
)
```


Number of rows in dataframe, hw1q2_df: `r nrow(hw1q2_df)`

Number of columns in dataframe, hw1q2_df: `r ncol(hw1q2_df)`

Mean of dataframe, hw1q2_df: `r mean(pull(hw1q2_df, x))`

Median of dataframe, hw1q2_df: `r median(pull(hw1q2_df, x))`

Standard deviation of dataframe, hw1q2_df: `r sd(pull(hw1q2_df, x))`

Proportions of cases for which x + y > 1 in dataframe, hw1q2_df: `r mean(pull(hw1q2_df, q2_numeric))`

##ggplot_1: Make ggplot y vs x using color = q2_logical. 
```{r}
ggplot(hw1q2_df, aes(x = x, y = y, color = q2_logical)) + 
  geom_point()
```

##ggplot_2: Make ggplot y vs x using color = q2_numeric. 
```{r}
ggplot(hw1q2_df, aes(x = x, y = y, color = q2_numeric)) + 
  geom_point()
```

##ggplot_3: Make ggplot y vs x using color = q2_factor. 
```{r}
ggplot(hw1q2_df, aes(x = x, y = y, color = q2_factor)) + 
  geom_point()
```







